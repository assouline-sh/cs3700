#!/usr/bin/env python3

import argparse, socket, select, ssl, html, html.parser, re
from html.parser import HTMLParser
from urllib.parse import urlparse

DEFAULT_SERVER = "proj5.3700.network"
DEFAULT_PORT = 443
csrf_middleware_token = ""
csrf_token = ""
sessionid = ""

FLAGS = []

class Parser(HTMLParser):
	def handle_starttag(self, tag, attrs):
		global csrf_middleware_token
		attrs = dict(attrs)
		if ('name' in attrs) and (attrs['name'] == 'csrfmiddlewaretoken'):
			csrf_middleware_token = attrs['value']
			print("CSRF MIDDLEWARE TOKEN: " + csrf_middleware_token)
			return
	def handle_data(self, data):
		# When all flags are found, print them out and exit the program
		if (len(FLAGS) == 5):
			for flag in FLAGS:
				print(flag)
			exit(0)

class Crawler:
	# Initialize variables for the server and port to connect to, and the username and password to use 
	def __init__(self, args):
		if (args.server is None):
			self.server = DEFAULT_SERVER
		else:
			self.server = args.server
		if (args.port is None):
			self.port = DEFAULT_PORT
		else:
			self.port = args.port
		self.username = args.username
		self.password = args.password


	# Establish a TCP socket connection wrapped in TLS
	def socket(self):
		mysocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		mysocket.connect((self.server, self.port))
		context = ssl.create_default_context()
		mysocket = context.wrap_socket(mysocket, server_hostname = self.server)
		return mysocket


	# Receive response from the server, reconstructing data that arrives in chunks
	def receive_response(self, request):
		response = ""
		try:
			data = self.socket.recv(65535).decode('utf-8')
			print("MSG: " + str(data))
		except:
			self.socket.send(request.encode('ascii'))
		return data;


	# Use HTTP POST request to log in to Fakebook with provided credentials
	def login(self):
		# GET HTML request the Fakebook login page and receive response from site
		login_url = urlparse("https://" + str(self.server) + ":" + str(self.port) + "/accounts/login/?next=/fakebook/")
		get_request = "GET " + login_url.path + " HTTP/1.1\nHost: " + login_url.hostname + "\n\n" 
		self.socket.send(get_request.encode('utf-8'))
		get_response = self.socket.recv(65535).decode('utf-8')
		print("GET RESPONSE: \n" + str(get_response))

		# Get the csrf token and sessionid
		csrf_token = re.search('csrftoken=(.*); expires', get_response).group(1)
		sessionid = re.search('sessionid=(.*); expires', get_response).group(1)

		# Parse the HTML response to find the csrf middleware token
		parser = Parser()
		parser.feed(get_response)
		global csrf_middleware_token
		
		# POST HTML request to log in to the Fakebook site with given username and password
		content = "username=" + self.username + "&password=" + self.password + "&csrfmiddlewaretoken=" + csrf_middleware_token
		post_request = "POST " + login_url.path + " HTTP/1.1\nHost: " + login_url.hostname + "\n"
		post_request += "Content-Length: " + str(len(content)) + "\nContent-Type: application/x-www-form-urlencoded\n"
		post_request += "Cookie: csrftoken=" + csrf_token + "; sessionid=" + sessionid + "\n"
		post_request += "Referer: " + login_url.geturl() + "username=" + self.username + "\n\n" + content + "\n\n"
		print("POST REQUEST: " + post_request)
		self.socket.send(post_request.encode('utf-8'))
		print("REACHED BEFORE RECEIVING POST")
		post_response = self.socket.recv(65535).decode('utf-8')
		print("POST RESPONSE: \n" + str(post_response))

	def run(self):
		# Establish socket connection
		self.socket = self.socket()
		
		# Log in to Fakebook
		self.login()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='crawl Fakebook')
    parser.add_argument('-s', dest="server", type=str, default=DEFAULT_SERVER, help="The server to crawl")
    parser.add_argument('-p', dest="port", type=int, default=DEFAULT_PORT, help="The port to use")
    parser.add_argument('username', type=str, help="The username to use")
    parser.add_argument('password', type=str, help="The password to use")
    args = parser.parse_args()
    sender = Crawler(args)
    sender.run()
