#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, ast, zlib

DATA_SIZE = 1375

# Class for the sender
class Sender:
	# Initialize connection and global variables
	def __init__(self, host, port):
		self.host = host
		self.remote_port = int(port)
		self.log("Sender starting up using port %s" % self.remote_port)
		self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
		self.socket.bind(('0.0.0.0', 0))
		self.waiting = False
		self.all_msg = []
		self.to_send = []
		self.packets_in_transit = []
		self.sequence_num = 0
		self.sequences_sent = []
		self.RTT = 1
		self.WINDOW = 4


	# Log the given message to stderr
	def log(self, message):
		sys.stderr.write(message + "\n")
		sys.stderr.flush()


	# Send the given message to receiver
	def send(self, message):
		self.socket.sendto(json.dumps(message).encode('utf-8'), (self.host, self.remote_port))


	# Parse messages to send from standard input
	def get_data(self):
		while True:
			data = sys.stdin.read(DATA_SIZE)
			if len(data) == 0:
				# Stop receiving input when there is no more data to read
				break;
			else:
				# Format the message and append to to_send list
				msg = {"type": "msg", "data": data, "seq": self.sequence_num, "timesent": 0, "checksum": 0}
				self.sequence_num += 1
				checksum = json.dumps({"data": msg["data"]}).encode('utf-8')
				msg["checksum"] = zlib.crc32(checksum)
				self.to_send.append(msg)
				self.all_msg.append(msg)
				print("TO SEND: " + str(self.to_send))

	# Check if the given received message is corrupt
	def check_corrupt(self, msg):
		for packet in self.all_msg:
			if (msg["seq"] == packet["seq"]):
				print("in corrupt, same sequence")
				if (msg["type"] == "ack"):
					print("in corrupt, ack as type")
					if (msg["data"] == packet["data"]):
						print("in corrupt, data is same")
						return False
			else:
				continue
		return True


	# Parse response from receiver
	def response(self, k):
		msg = k.decode('utf-8')
		corrupt = False
		try:
			msg = json.loads(msg)
		except:
			corrupt = True
		print("RECEIVED MESSAGE LOOKS LIKE: " + str(msg))
		if (corrupt or self.check_corrupt(msg)):
			self.log("Received corrupt ACK: " + str(msg["seq"]))
			for packet in self.all_msg:
				if (packet["seq"] == msg["seq"]):
					packet["timesent"] = int(time.time())
					self.send(packet)
		else:
			self.log("Received ACK of Sequence: " + str(msg["seq"]))
			temp_str = ""
			# Remove received packet from list of packets_in_transit
			for packet in self.packets_in_transit:
				if (msg["seq"] == packet["seq"]):
					self.packets_in_transit.remove(packet)
				else:
					temp_str += str(packet["seq"]) + ", "
				self.log("UPDATED PACKETS_IN_TRANSIT AFTER ACK: " + str(temp_str))	
		self.waiting = False

		# If there are no packets left to send, exit
		if (len(self.packets_in_transit) == 0):
			self.log("All done!")
			sys.exit(0)


	# Resend packets if they have exceeded the RTT without an ACK (have been dropped)
	def dropped(self):
		for packet in self.packets_in_transit:
			current = int(time.time())
			if (current > packet["timesent"] + (self.RTT * 2)):
				self.log("Resending Packet of Sequence: '%s'" % str(packet["seq"]))
				packet["timesent"] = int(time.time())
				checksum = json.dumps({"data": packet["data"]}).encode('utf-8')
				packet["checksum"] = zlib.crc32(checksum)
				self.send(packet)


	# Send more packets if it does not exceed the window
	def send_more(self):
		while ((len(self.packets_in_transit) < self.WINDOW) and (len(self.to_send) >= 1)):
			# If the packet is not a duplicate
			if not(self.to_send[0]["seq"] in self.sequences_sent):
				self.log("Sending Message of Sequence: '%s'" % str(self.to_send[0]["seq"]))
				self.to_send[0]["timesent"] = int(time.time())
				self.send(self.to_send[0])
				self.sequences_sent.append(self.to_send[0]["seq"])
				self.packets_in_transit.append(self.to_send[0])
				del self.to_send[0]
			else:
				self.to_send.remove(self.to_send[self.packets_in_transit])
			self.waiting = True


	def run(self):
		# Get messages to be sent
		self.get_data()
		
		while True:
			sockets = [self.socket, sys.stdin] if not self.waiting else [self.socket]
			socks = select.select(sockets, [], [], 0.1)[0]
			for conn in socks:
				# Receive data from receiver
				if conn == self.socket:
					k, addr = conn.recvfrom(65535)
					self.response(k)

				# Receive data from standard input
				elif conn == sys.stdin:
					self.dropped()
					self.send_more()
		return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('host', type=str, help="Remote host to connect to")
    parser.add_argument('port', type=int, help="UDP port number to connect to")
    args = parser.parse_args()
    sender = Sender(args.host, args.port)
    sender.run()
