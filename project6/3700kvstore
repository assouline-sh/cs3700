#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"
leader = "FFFF"
state = "follower"											# When servers start up, they begin as followers
term = 0
election_timeout = random.randint(150, 300) / 1000			# Generally election timeout is 150ms - 300ms
votes = 0
transaction_log = [{"buffer"}]								# Initialize log with a buffer, since log index should start from 1
state_machine = {}											# Store key-value pairs

class Replica:
	def __init__(self, port, id, others):
		self.port = port
		self.id = id
		self.others = others

		self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
		self.socket.bind(('localhost', 0))

		print("Replica %s starting up" % self.id, flush=True)
		hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
		self.send(hello)
		print("Sent hello message: %s" % hello, flush=True)

	def send(self, message):
		self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))


	def parse_message(self, msg):
		global transaction_log, term
		if (state == "leader"):
			if (msg['type'] == 'put'):
				try:
					state_machine.update({msg['key']: msg['value']})
				except:
					response_fail = { "src": self.id, "dst": msg['src'], "leader": leader, "type": "fail", "MID": msg['MID'] }
					self.send(response_fail)
					return
				transaction_log.append({"command": "put", "key": msg['key'], "value": msg['value'], "term": term})
				# Send append entries to all replicas
				put_ok = { "src": self.id, "dst": msg['src'], "leader": leader, "type": "ok", "MID": msg['MID'] }
				self.send(put_ok)
			elif (msg['type'] == 'get'):
				try:
					value = state_machine.get(msg['key'])
					if (value):
						get_ok = { "src": self.id, "dst": msg['src'], "leader": leader, "type": "ok", "MID": msg['MID'], "value": value }
					else:
						get_ok = { "src": self.id, "dst": msg['src'], "leader": leader, "type": "ok", "MID": msg['MID'], "value": '' }
					self.send(get_ok)
				except:
					response_fail = { "src": self.id, "dst": msg['src'], "leader": leader, "type": "fail", "MID": msg['MID'] }
					self.send(response_fail)
					return
		else:
			response_redirect = { "src": self.id, "dst": msg['src'], "leader": leader, "type": "redirect", "MID": msg['MID'] }
			self.send(response_redirect)

	# Start an election by incrementing the current term by one, transitioning to the candidate state, voting for yourself, and issuing RequestVote RPCs to other servers
	def send_request_vote_RPC(self):
		global term, state, votes, transaction_log
		term += 1
		state = "candidate"
		votes += 1
		request_vote = { "src": self.id, "dst": BROADCAST, "leader": leader, "type": "request_vote", "term": term, "candidate_id": self.id, "last_log_index": len(transaction_log) - 1, "last_log_term": transaction_log[-1]['term']}
		self.send(request_vote)


	# Vote for a candidate if it has a higher last log term, or if the last log term is equal then vote for a candidate if it has a longer log
	def receive_request_vote_RPC(self, message):
		global transaction_log, term
		if (message['last_log_term'] > transaction_log[-1]['term']) or ((message['last_log_term'] == transaction_log[-1]['term']) and (message['last_log_index'] >= len(transaction_log) - 1)):
			vote = { "src": self.id, "dst": message['src'], "leader": leader, "type": "cast_vote", "vote": True, "term": term}
		elif (message['last_log_term'] < transaction_log[-1]['term']) or ((message['last_log_term'] == transaction_log[-1]['term']) and (message['last_log_index'] < len(transaction_log) - 1)):
			vote = { "src": self.id, "dst": message['src'], "leader": leader, "type": "cast_vote", "vote": False, "term": term}
		self.send(vote)


	def count_request_vote_RPC(self, message):
		global votes, state, term, leader
		if (message['term'] > term):
			#something
			return
		if (message['vote']):
			votes += 1
		if (votes >= len(self.others) / 2):
			leader = self.id
			state = "leader"
			votes = 0
			# send a heartbeat
		else:
			state = "follower"
	

	def send_append_entry_RPC(self, message):
		global term,transaction_log

		message = { "src": self.id, "dst": BROADCAST, "leader": leader, "type": "append_entry", "term": term, "entries": "", "prev_log_index": "", "prev_log_term": "", "leader_commit": ""}


	def run(self):
		while True:
			socks = select.select([self.socket], [], [], 0.1)[0]
			for conn in socks:
				data, addr = conn.recvfrom(65535)
				msg = json.loads(data.decode('utf-8'))
				print("OTHERS: " + str(self.others))
				print("RECEIVED MESSAGE: " + str(msg), flush=True)

				if (state != "leader"):
					response_redirect = { "src": self.id, "dst": msg['src'], "leader": leader, "type": "redirect", "MID": msg['MID'] }
					self.send(response_redirect)
				else:
					response_fail = { "src": self.id, "dst": msg['src'], "leader": leader, "type": "fail", "MID": msg['MID'] }
					self.send(response_fail)
#			try:
#				if (msg['type'] == 'put'):
#					database.update({msg['key']: msg['value']})
#					put_ok = { "src": self.id, "dst": msg['src'], "leader": BROADCAST, "type": "ok", "MID": msg['MID'] }
#					self.send(put_ok)
				#elif (msg['type'] == 'get'):
				#	get_ok = { "src": self.id, "dst": msg['src'], "leader": BROADCAST, "type": "ok", "MID": msg['MID'], "value": database[msg['key']] }
				#	self.send(get_ok)
#			except:
#				response_fail = { "src": self.id, "dst": msg['src'], "leader": BROADCAST, "type": "fail", "MID": msg['MID'] }
#				self.send(response_fail)
			
#			print("DATABASE: " + str(database))
			#self.parse_message(msg)
			

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='run a key-value store')
	parser.add_argument('port', type=int, help="Port number to communicate")
	parser.add_argument('id', type=str, help="ID of this replica")
	parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
	args = parser.parse_args()
	replica = Replica(args.port, args.id, args.others)
	replica.run()
