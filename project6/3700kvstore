#!/usr/bin/env python3
import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"
leader = "FFFF"												
state = "follower"															# When servers start up, they begin as followers
state_machine = {}															# Store key-value pairs
votes = 0																	# A replica's garnered votes during an election
last_heartbeat = time.time()												# Initialize starting time
election_timeout = random.randint(150, 300) / 1000
# Persistent state on all servers
current_term = 0
voted_for = None															# Candidate ID that received vote in current term
log = [{"command": None, "key": None, "value": None, "term": None}]			# Starts at index 1, so initialize with buffer for index 0								
# Volatile state on all servers
commit_index = 0															# Index of highest log entry known to be commited
last_applied = 0 															# Index of highest log entry applied to state machine
# Volatile state on leaders, reinitialized after election
next_index = {}																# For each server, index of the next log entry to send to that server
match_index = {}															# For each server, index of highest log entry known to be replicated on server


# A class for each replica machine
class Replica:
	# Initiate socket connection and send "hello" message to all replicas
	def __init__(self, port, id, others):
		self.port = port
		self.id = id
		self.others = others

		self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
		self.socket.bind(('localhost', 0))
		print("Replica %s starting up" % self.id, flush=True)

		hello = {"src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello"}
		self.send(hello)


	# Send message to given destination
	def send(self, message):
		self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))
		print("Sent " + str(message['type']) + " Message: " + str(message), flush = True)


	# Return randomized election timeout period, generally between 150ms - 300ms, to reduce probability of concurrent elections
	def get_election_timeout(self):
		return random.randint(150, 300) / 1000


	# Parse the "put" or "get" message, and perform the command requested
	def parse_message(self, msg):
		global leader, log, current_term, last_applied, state_machine
		if (msg['type'] == 'put'):
			try:
				# Put key-value pair in state machine
				state_machine.update({msg['key']: msg['value']})
			except:
				response_fail = {"src": self.id, "dst": msg['src'], "leader": leader, "type": "fail", "MID": msg['MID']}
				self.send(response_fail)
				return
			# Log the "put" command for the given key and value in the log
			log.append({"command": "put", "key": msg['key'], "value": msg['value'], "term": current_term})
			last_applied += 1
			# Respond with "ok" message to confirm "put" was successful
			put_ok = {"src": self.id, "dst": msg['src'], "leader": leader, "type": "ok", "MID": msg['MID'] }
			self.send(put_ok)
			# Send append_entry responses to all replicas with new information about the log
			self.send_append_entry_RPC([{msg['key']: msg['value']}])
			
		elif (msg['type'] == 'get'):
			try:
				# Get the value of the given key from the state machine if it exists
				if msg['key'] in state_machine:
					get_ok = {"src": self.id, "dst": msg['src'], "leader": leader, "type": "ok", "MID": msg['MID'], "value": state_machine.get(msg['key'])}
				else:
					get_ok = {"src": self.id, "dst": msg['src'], "leader": leader, "type": "ok", "MID": msg['MID'], "value": ''}
			except:
				response_fail = {"src": self.id, "dst": msg['src'], "leader": leader, "type": "fail", "MID": msg['MID'] }
				self.send(response_fail)
				return
			# Respond with the value if the key was found, or an empty value if no key was found
			self.send(get_ok)


	# Start an election by incrementing the current term by one, transitioning to the candidate state, voting for yourself, and issuing RequestVote RPCs to other servers
	def send_request_vote_RPC(self):
		global current_term, state, votes, last_heartbeat, log, election_timeout
		print(str(self.id) + " IS REQUESTING VOTES")
		current_term += 1
		state = "candidate"
		votes = 1
		election_timeout = self.get_election_timeout()
		request_vote = {"src": self.id, "dst": BROADCAST, "leader": leader, "type": "request_vote", "term": current_term, "candidate_id": self.id, "last_log_index": len(log) - 1, "last_log_term": log[-1]['term']}
		self.send(request_vote)


	# Vote for a candidate if it has a higher last log term, or if the last log term is equal then vote for a candidate if it has a longer log
	def receive_request_vote_RPC(self, msg):
		global voted_for, log, current_term
		print(str(self.id) + " is VOTING")
		if (voted_for == None) or (voted_for == msg['candidate_id']):
			if (msg['last_log_term'] > log[-1]['term']) or ((msg['last_log_term'] == log[-1]['term']) and (msg['last_log_index'] >= len(log) - 1)):
				vote = {"src": self.id, "dst": msg['src'], "leader": leader, "type": "cast_vote", "vote": True, "term": current_term, "candidate_id": msg['candidate_id']}
				voted_for = msg['candidate_id']
			elif (msg['last_log_term'] < log[-1]['term']) or ((msg['last_log_term'] == log[-1]['term']) and (msg['last_log_index'] < len(log) - 1)):
				vote = {"src": self.id, "dst": msg['src'], "leader": leader, "type": "cast_vote", "vote": False, "term": current_term, "candidate_id": msg['candidate_id']}
			self.send(vote)


	# Count the number of votes from other replicas to determine if candidate is the new leader
	def count_request_vote_RPC(self, msg):
		global votes, state, leader, next_index, match_index
		if (self.id == msg['candidate-id']):
			# If a vote is cast, count it
			if (msg['vote']):
				votes += 1
			# If candidate has received majority of votes, set it as the new leader, send heartbeat, and reinitialize volatile state
			if (votes >= math.ceil(len(self.others) / 2)):
				leader = self.id
				state = "leader"
				print(str(self.id) + " has become the leader")
				self.send_append_entry_RPC([])
				next_index = {}
				match_index = {}
				for replica in self.others:
					next_index.update({replica: len(log)})
					match_index.update({replica: 0})


	# Send a message from leader to replicate log entries to other replicas or to send a heartbeat that maintains authority
	def send_append_entry_RPC(self, entries):
		global current_term, log, last_heartbeat
		append_entry = {"src": self.id, "dst": BROADCAST, "leader": leader, "type": "append_entry", "term": current_term, "entries": entries, "prev_log_index": len(log) - 2, "prev_log_term": log[-2]['term'], "leader_commit": commit_index}
		self.send(append_entry)


	def receive_append_entry_RPC(self, msg):
		global current_term, leader, state, commit_index, log
		# No need to respond to heartbeat messages
		if not (msg['entries']):
			return
		# If in an election and an append entry RPC is received from a new leader, convert to follower
		if (state == "candidate") and (msg['src'] == msg['leader']):
			if (msg['term'] > current_term):
				leader = msg['leader']
				state = "follower"
			else:
				return
	
		# Return False if follower's log is inconsistent with the leader's log
		if (msg['term'] < current_term) or (log[msg['prev_log_index']]['term'] != msg['prev_log_term']):
			append_entry_response = {"src": self.id, "dst": msg['src'], "leader": leader, "type": "append_entry_response", "term": current_term, "success": False}
			self.send(append_entry_response)
			return

		# If an existing entry conflicts, delete the existing entry and all that follow it
		if (len(log) > msg['prev_log_index'] + 1):
			for i in range(msg['prev_log_index'] + 1, len(log)):
				del log[i]
		# Append any new entries not already in the log
		for entry in msg['entries']:
			log.append({"command": "put", "key": list(entry.keys())[0], "value": list(entry.values())[0], "term": current_term})
		
		# Update the commit index
		if (msg['leader_commit'] > commit_index):
			commit_index = math.min(msg['leader_commit'], len(log) - 1)

		# Return True if appending entries was successful
		append_entry_response = {"src": self.id, "dst": msg['src'], "leader": leader, "type": "append_entry_response", "term": current_term, "success": True}
		self.send(append_entry_response)

		



		
	def run(self):
		global leader, last_heartbeat, election_timeout
		while True:
			socks = select.select([self.socket], [], [], 0.1)[0]
			for conn in socks:
				data, addr = conn.recvfrom(65535)
				msg = json.loads(data.decode('utf-8'))
				# ! Temporary for clearing debug
				if (msg['type'] != "append_entry"):
					print("RECEIVED MESSAGE: " + str(msg))

				# Parse "put" or "get" data messages
				# If this machine is the leader, parse the received message, else redirect the message
				if (msg['type'] == "put" or msg['type'] == "get") and (state == "leader"):
					self.parse_message(msg)
				elif (msg['type'] == "put" or msg['type'] == "get") and (state != "leader"):
					response_redirect = { "src": self.id, "dst": msg['src'], "leader": leader, "type": "redirect", "MID": msg['MID'] }
					self.send(response_redirect)

				# Parse append messages
				if (msg['type'] == "append_entry"):
					self.receive_append_entry_RPC()

				# Parse messages relating to elections
				# Determine whether or not to cast a vote
				if (msg['type'] == "request_vote"):
					self.receive_request_vote_RPC(msg)

				# Count received vote to determine if a new leader has been elected
				if (msg['type'] == "cast_vote"):
					self.count_request_vote_RPC(msg)

			# If this machine is a leader, send periodic heartbeats to all followers to maintain authority
			if (state == "leader") and (time.time() - last_heartbeat > 0.1):
				print("SENDING HEARTBEAT")
				self.send_append_entry_RPC([])
				last_heartbeat = time.time()
				
			# If this machine is a follower and has not received a valid RPC within the election timeout period, start election
			if (state == "follower") and (time.time() - last_heartbeat > election_timeout):
				print("STARTING ELECTION")
				self.send_request_vote_RPC()	
			

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='run a key-value store')
	parser.add_argument('port', type=int, help="Port number to communicate")
	parser.add_argument('id', type=str, help="ID of this replica")
	parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
	args = parser.parse_args()
	replica = Replica(args.port, args.id, args.others)
	replica.run()
